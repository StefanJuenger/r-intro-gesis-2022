---
title: "Introduction to R for Data Analysis"
subtitle: "Data Wrangling - Part 1"
author: "Johannes Breuer, Stefan Jünger, & Veronika Batzdorfer"
date: "2022-08-16"
presenter: Veronika
---
layout: true 

```{r child = "content/config/sessions_setup.Rmd"}
```

---

## Data wrangling 



```{r, wrangling-cartoon, out.width = "95%", echo = F}
woRkshoptools::include_picture("./wrangl.jpg")
```



The process of re-**shaping**, re-**formatting**, and re-**arranging** raw data for analysis
---

## Steps of data wrangling



Steps when working with tabular data in the social & behavioral sciences (e.g., from surveys) include:

- **selecting** a subset of variables
- **renaming** variables
- **relocating** variables
- **filtering** a subset of cases


- **recoding** variables/values
- **missing values** recoding
- **creating/computing** new variables

--

<small>The (in)famous **80/20-rule**: 80% wrangling, 20% analysis (of course, this ratio relates to the time required for writing the code, not the computing time).<small>

---

## The `tidyverse`


> The `tidyverse` is a coherent system of packages for .highlight[data manipulation, exploration and visualization] that share a common design philosophy ([Rickert, 2017](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/)).

```{r tidyverse-hex, out.width = "25%", echo = F}
knitr::include_graphics("https://github.com/rstudio/hex-stickers/raw/master/thumbs/tidyverse.png")
```


---

## Benefits of the `tidyverse`

Data wrangling can also be done with `base R`. However, the syntax for this is typically (more) verbose and not intuitive and, hence, difficult to learn, remember, and read (plus many `tidyverse` operations are faster than their base `R` equivalents).



`Tidyverse` syntax is designed to increase

- **human-readability** making it **attractive for `R` novices** as it can facilitate **self-efficacy** (see [Robinson, 2017](http://varianceexplained.org/r/teach-tidyverse/))
- **consistency** (e.g., data frame as first argument and output) 
- **smarter defaults** (e.g., no partial matching of data frame and column names).

---

## The 'dark side' of the `tidyverse`

`tidyverse` is not `R` as in `base R`
- some routines are like using a whole different language, which...
  - ... can be nice when learning `R`
  - ... can get difficult when searching for solutions to certain problems

- Often, `tidyverse` functions are under heavy development
  - they change and can potentially break your code
    - E.g.: [Converting tables into long or wide format](https://tidyr.tidyverse.org/news/index.html#pivoting)<small>
  
To learn more about the `tidyverse` lifecycle you can watch this [talk by Hadley Wickham](https://www.youtube.com/watch?v=izFssYRsLZs) or read the corresponding [documentation](https://lifecycle.r-lib.org/articles/stages.html#deprecated)

---

## `Base R` vs. `tidyverse`

Similar to other fierce academic debates over, e.g., `R` vs. `Python` or Frequentism vs. Bayesianism, people have argued [for](http://varianceexplained.org/r/teach-tidyverse/) and [against](https://blog.ephorie.de/why-i-dont-use-the-tidyverse) using/teaching the `tidyverse`.

But what's unites both:


```{r tidy-bf, out.width="60%", echo=FALSE}
knitr::include_graphics("https://miro.medium.com/max/1280/0*ifjhcLyODu0nXjVx.jpg")
```
.center[
<small><small>Source: https://bit.ly/3PmcL4t</small></small>
]

---

## Data wrangling alternatives

As with almost all tasks in `R`, there are more than two packages for data wrangling. Two alternatives (or additions) to `base R` and the `tidyverse` are:
- [`data.table`](https://rdatatable.gitlab.io/data.table/index.html)
- [`datawizard`](https://easystats.github.io/datawizard/)

---

## `data.table`

The `data.table` package also is a powerful tool for data wrangling, especially if you work with large data sets. The reason we do not discuss `data.table` in this course is that neither of us has extensive experience with it, and comparing all three options (`base R`, `tidyverse`, and `data.table`) side-by-side would be enough for a separate workshop/course.

There is, however, a very detailed [blog post by Jason Mercer](https://wetlandscapes.com/blog/a-comparison-of-r-dialects/) that compares the functionalities of `base R`, `tidyverse`, and `data.table` for data wrangling and [another one by Atreba](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/) that focuses on a comparison between `data.table` and [`dplyr`](https://dplyr.tidyverse.org/) which is a key package for data manipulation from the `tidyverse`. 

---

# `datawizard` `r emo::ji("mage")`

`datawizard` is a fairly new contender in the data wrangling game that also offers quite a few handy and easy to use functions. `datawizard` is part of the [`easystats` collection of `R` packages](https://easystats.github.io/easystats/) which offer many helpful functionalities for data preparation, analysis, and reporting, which can nicely extend or complement the `tidyverse`. We will discuss some of the `easystats` packages again in the sessions on exploratory and confirmatory data analysis.

---

## Structure & focus of this session

- focus on differences between `base R` and the `tidyverse`

- our main focus will be on the use of packages (and functions) from the `tidyverse` and how they can be used to clean and transform your data.

Of course, it is possible to combine `base R` and `tidyverse` code. However, in the long run, you should try to aim for consistency.

---

## Lift-off into the `tidyverse` `r ji("rocket")`

**Install all `tidyverse` packages** (for the full list of `tidyverse` packages see [https://www.tidyverse.org/packages/](https://www.tidyverse.org/packages/))
```{r install-tidyverse, eval = F}
install.packages("tidyverse")
```
**Load core `tidyverse` packages** (NB: To save time and reduce namespace conflicts you can also load `tidyverse` packages individually)
```{r load-tidyverse, message = T}
library("tidyverse") ##load the tidyverse package
```

---

## `tidyverse` vocabulary 101

While there is much more to the `tidyverse` than this, three important concepts that you need to be familiar with, if you want to use it, are:

1. Tidy data

2. Tibbles

3. Pipes

<small>(We already discussed tibbles in the session on *Data Import & Export*, so we will focus on tidy data and pipes here.)<small>

---

## Tidy data `r ji("cowboy_hat_face")`

The 3 rules of tidy data:

1. Each **variable** is in a separate **column**.

2. Each **observation** is in a separate **row**.

3. Each **value** is in a separate **cell**.


```{r tidy-data, echo = FALSE}
knitr::include_graphics("https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png")
```
<small><small>Source: https://r4ds.had.co.nz/tidy-data.html</small></small>

*Note*: In the `tidyverse` terminology 'tidy data' usually also means data in long format (where applicable).

---

## Wide vs. long format

```{r wide-long-pic, echo = FALSE, out.width="45%"}
knitr::include_graphics("https://raw.githubusercontent.com/gadenbuie/tidyexplain/main/images/static/png/original-dfs-tidy.png")
```
<small><small>Source: https://github.com/gadenbuie/tidyexplain#tidy-data</small></small>

.small[
*Note*: The functions `pivot_wider()` and `pivot_longer()` from the [`tidyr` package](https://tidyr.tidyverse.org/) are easy-to-use options from changing data from long to wide format and vice versa.
]

---


## Pipes (%>% == and then)

Usually, in `R` we apply functions as follows:

```{r function-r, eval = FALSE}
f(x)
```

In the logic of pipes this function is written as:

```{r function-pipe, eval = FALSE}
x %>% f(.)
```

Here, object `x` is piped into function `f`, becoming (by default) its first argument (but by using *.* it can also be fed into other arguments).

--

We can use pipes with more than one function:

```{r function-pipe-2, eval = FALSE}
x %>% 
  f_1() %>% 
  f_2() %>% 
  f_3()
```

.small[
More about pipes: https://r4ds.had.co.nz/pipes.html
]

---

## Pipes

- The `%>%` used in the `tidyverse` is part of the [`magrittr` package](https://magrittr.tidyverse.org/) which also includes other specialized types of pipes.

- *RStudio* offers a keyboard shortcut for inserting **`%>%`**: <kbd>Ctrl + Shift + M</kbd> (*Windows* & *Linux*)/<kbd>Cmd + Shift + M</kbd> (*Mac*)

- Since [version 4.1.0](https://cran.r-project.org/bin/windows/base/NEWS.R-4.1.0.html), `base R` also offers its own pipe `|>`, which is similar to but not the same as the `%>%` pipe.

---

## Data set

For the examples and exercises in this session we will, again, use data from the [*German General Social Survey (ALLBUS) 2021*](https://search.gesis.org/research_data/ZA5280).

.highlight[Remember]: to code along/ for the exercises the *ALLBUS* data file should be in a sub-folder called `data` in the same folder, as the other materials for this course.

---
## Note: Tidy vs. untidy data

The *GESIS German General Social Survey (ALLBUS) 2021* is already tidy.
If you collect data yourself, the raw data may be `untidy`, e.g.:
- cells may hold more than one value
- a variable that should be in one column is spread across multiple columns (e.g., parts of a date or name).


If you need to make your data tidy or change it from wide to long format or vice versa (which may, e.g., be necessary if you work with longitudinal survey data from multiple waves), the [`tidyr` package](https://tidyr.tidyverse.org/) from the `tidyverse` is a good option.

---
## Interlude 1: Citing data

If you (re-)use existing data sets, please cite them in your publications, theses, teaching materials, etc. Data repositories normally provide information on how to cite the data. For example, the APA-style citation for *Public Use File (PUF) of the German General Social Survey (ALLBUS) 2021* is:

GESIS - Leibniz-Institut für Sozialwissenschaften (2022). ALLBUS/GGSS 2021 (Allgemeine Bevölkerungsumfrage der Sozialwissenschaften/ German General Social Survey 2021). *GESIS, Cologne. ZA5280 Data file Version 1.0.0, https://doi.org/10.4232/1.13954*.

---

## Interlude 2: Citing FOSS

You should also make sure to cite the free and open-source software that you use, such as `R` packages and `R` itself. There is a function in `R` that tells you how to cite it or any of the packages you have used (for this please see `sessionInfo()`).

```{r citation}
citation()
```

---

## Interlude 3: Codebook

It is always advisable to consult the codebook (if there is one) before starting to work with a data set. The *GESIS German General Social Survey (ALLBUS) 2021* comes with a very [detailed codebook](https://dbk.gesis.org/DBKSearch/download.asp?file=ZA5280_fb_CAWI.pdf).

Side note: If you want to (semi-)automatically generate a codebook for your own dataset, there are several options in `R`:

- the [`codebook` package](https://rubenarslan.github.io/codebook/) which includes an *RStudio*-Addin and also offers a [web app](https://rubenarslan.ocpu.io/codebook/www/)

- the `makeCodebook()` function from the [`dataReporter` package](https://github.com/ekstroem/dataReporter) (see this [blog post](http://sandsynligvis.dk/articles/18/codebook.html) for a short tutorial of the initial `dataMaid package`)

---

## Load the data

The first step is loading the data into `R`.

```{r load-albus2021-data}
library(haven)#to load foreign data formats such as from SPSS into R
library(sjlabelled)

allbus_2021 <- read_sav("./data/allbus_2021ZA5280_v1-0-0.sav",
                       user_na = TRUE) %>% 
  remove_all_labels() %>% 
  as_tibble()
```

---


## `dplyr`

The `tidyverse` examples in the following will make use of [`dplyr` functions](https://dplyr.tidyverse.org/) that are **verbs** that signal an action (e.g. `group_by()`, `glimpse()`, `filter()`)
Their structure is:
1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame.
3. The result is a new data frame (tibble).

  - **columns** (= variables in a tidy data frame) can be referenced without quotation marks (non-standard evaluation)
  - **actions** (verbs) can be applied to columns (variables) and rows (cases/observations)




---

## First look `r ji("eyes")`

The `dplyr` package provides a function for getting a first good look at your data, that is especially helpful when working with data sets that contain many columns/variables. The function `glimpse()` prints a data frame/tibble in a way that represents columns as rows and rows as columns and also provides some additional information about the data frame and its columns.

```{r glimpse, eval=FALSE}
allbus_2021 %>% 
  glimpse()
```

.right[`r emo::ji("left_arrow_curving_right")`]

---

class: middle

.tinyisher[
```{r ref.label = "glimpse", echo = FALSE}
```
]

---

## Selecting variables

We might want to reduce our data frame (or create a new one) to only include a **subset of specific variables**. Say, for example, we want to select only the variables that measure attitudes towards *immigration* (`mi05-mi11`) from our full data set. There are two options for doing this with `base R`:

Option 1
.small[
```{r select-vars-base}
allbus_immigration <- allbus_2021[, c("mi05", "mi06", "mi07", "mi08", "mi09", "mi10","mi11")]
# When subsetting with [], the first value refers to rows, the second to columns
# [, c("var1", "var2", ...)] means we want to select all rows but only some specific columns.
```
]

Option 2
.small[
```{r subset}
allbus_immigration <- subset(allbus_2021, TRUE, select = c(mi05, mi06, mi07, mi08, mi09, mi10, mi11))
# Again, here the 2nd argument refers to the rows.
# Setting it to TRUE means that we want to include all rows in the subset.
```
]

---

## Selecting variables

You can also select variables based on their numeric index.

```{r subset-base-index}
allbus_immigration <- allbus_2021[, 39:45]

names(allbus_immigration)
```

---

## Selecting variables

In the `tidyverse`, we can create a subset of variables with the `dplyr` verb `select()`.

```{r select}
allbus_immigration <- allbus_2021 %>% 
  select(mi05,
         mi06,
         mi07,
         mi08,
         mi09,
         mi10,
         mi11)

head(allbus_immigration)
```

---

## Selecting a range of variables

There also is a shorthand notation for selecting a set of consecutive columns with `select()`.

```{r select-range}
allbus_immigration <- allbus_2021 %>% 
  select(mi05:mi11)

head(allbus_immigration)
```

*Note*: You can also use this shorthand notation for the `select` argument of the `base R` function `subset()`.

---

## Selecting a range of variables

Same as for `base R`, you can also use the numeric index of variables in combination with `select()` from `dplyr`.

```{r select-index}
allbus_immigration <- allbus_2021 %>% 
  select(39:45)

names(allbus_immigration)
```

---

## Unselecting variables

If you just want to exclude one or a few columns/variables, it is easier to unselect those than to select all others. Again, there's two ways to do this with `base R`.

Option 1
.small[
```{r unselect-base}
allbus_2021_cut <- allbus_2021[!(names(allbus_2021) %in% c("za_nr", "version", "doi"))]
# The ! operator means "not" (i.e., it negates a condition)
# The %in% operator means "is included in" (in this case the following character vector)

dim(allbus_2021_cut)
```
]

Option 2
.small[
```{r subset-unselect}
allbus_2021_cut  <- subset(allbus_2021, TRUE, select = -c(za_nr, version, doi))

dim(allbus_2021_cut)
```
]

---

## Unselecting variables

You can also use `select()` from `dplyr` to exclude one or more columns/variables.

```{r unselect}
allbus_2021_cut<- allbus_2021%>% 
  select(-c(za_nr, version, doi))

dim(allbus_2021_cut)
```

---

## Advanced ways of selecting variables

`dplyr` offers several helper functions for selecting variables. For a full list of those, you can check the [documentation for the `select()` function](https://dplyr.tidyverse.org/reference/select.html) or `?select()`.

```{r select-helper}
allbus_2021_mj <- allbus_2021 %>% 
  select(starts_with("mi"))

allbus_2021_stat <-allbus_2021 %>% 
  select(ends_with("stat"))

glimpse(allbus_2021_stat)
```

---

## Advanced ways of selecting variables

Another particularly useful selection helper is `where()` to select only a specific type of variables.

```{r where-num}
allbus_2021_num <- allbus_2021 %>% 
  select(where(is.numeric)) %>% 
  print()
```

---

## What's in a name?

One thing that we need to know - and might want to change - are the names of the variables in the dataset.

```{r names-gpc}
names(allbus_2021)
```

---

## What's in a name?

As you can see, only a few of the variable names in the *GESIS German General Social Survey (ALLBUS) 2021* data set are self-explanatory. <br/> The other variable names are composed of codes representing 
- the study wave 
- study name 
- variable number 
- original or derived variables.

<br/> 
Hence, for analyzing them it can make sense to **rename** them. 

---

## Renaming variables

It is good practice to use consistent naming conventions. Since `R` is .highlight[case-sensitive], we might want to only use lowercase letters.<br/> 
As spaces in variable names can cause problems, we could, e.g., decide to use `r ji("snake")` *snake_case* (`r ji("camel")`<br/> <br/> 
*camelCase* is a common alternative; for a good brief discussion of options for avoiding spaces in variable names, see this [Medium post by Patrick Divine](https://medium.com/@pddivine/string-case-styles-camel-pascal-snake-and-kebab-case-981407998841)).

---

# Become an ace of case

```{r, case-cartoon, out.width = "80%", echo = F}
knitr::include_graphics("https://github.com/allisonhorst/stats-illustrations/raw/main/other-stats-artwork/coding_cases.png")
```
<small><small>Artwork by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## Renaming variables

You can rename individual columns/variables in `base R` as follows:

```{r rename-base, eval=FALSE}
colnames(allbus_2021)[colnames(allbus_2021) == "lm35"] <- "internet_info_seek"
```

As for subsetting, you can also rename variables based on their numeric index.

```{r base-rename-index, eval=FALSE}
colnames(allbus_2021)[4] <- "respondent_id"
```

---

## Renaming variables

An easier to use and more versatile option for renaming columns/variables is the `dplyr` function `rename()`.

```{r rename}
allbus_immigration <- allbus_2021 %>% 
  rename(immig_war = mi05, # new_name = old_name
         immig_prosecut = mi06,
         immig_economic = mi07,
         immig_east = mi08,
         immig_eu = mi09,
         immig_noneu = mi10,
         immig_family = mi11)


names(allbus_immigration)
```

---

## Renaming variables

For some more advanced renaming options, you can use the `dplyr` function `rename_with()`.

*Note*: The [`janitor` package](https://sfirke.github.io/janitor/) (which is `tidyverse`-oriented) can be used to facilitate several common data cleaning tasks. Among other things, it contains the function `clean_names()` that takes a data frame and creates column names that "are unique and consist only of the _ character, numbers, and letters" (from the help file for this function), with the default being `r ji("snake")` snake_case (but support for many other types of cases).

```{r rename-with}
allbus_immigration %>% 
  rename_with(toupper) %>% 
  names()
```

 

---

## Renaming variables

We can use `rename_with()` in combination with `gsub()` (which we've already encountered in the session on *Getting Started*) to remove (or change) prefixes in variable names.

```{r rename-with-prefix}
allbus_2021 %>% 
  select(mi05:mi11) %>% 
  rename_with(~ gsub("mi", "immigrat_", .x,
                     fixed = TRUE)) %>% 
  names()
```

---

## Re~~wind~~name selecta

A nice thing about the `dplyr` verb `select` is that you can use it to select and rename variables in one step.

.small[
```{r select-rename}
allbus_immigration <- allbus_2021 %>% 
  select(immig_war = mi05, 
         immig_prosecut = mi06,
         immig_economic = mi07,
         immig_east = mi08,
         immig_eu = mi09,
         immig_noneu = mi10,
         immig_family = mi11)

head(allbus_immigration)
```
]

---

## Moving columns

Although the positions of columns in a data frame do not matter for analyses or plotting (unless you want to select columns using their numerical index), you might want to change them. For this purpose, `dplyr` provides the `relocate()` function.

```{r relocate}
allbus_immigration <- allbus_immigration %>% 
  relocate(immig_economic, .after = immig_noneu)

glimpse(allbus_immigration)
```

*Note*: You can also move a column before a specific other column by providing a variable name to the `.before` argument (instead of `.after`).



---

class: center, middle

# [Exercise](https://github.com/StefanJuenger/r-intro-gesis-2022/blob/main/exercises/Exercise_2_1_1_Selecting_Renaming_Steps.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://github.com/StefanJuenger/r-intro-gesis-2022/blob/main/solutions/Exercise_2_1_1_Selecting_Renaming_Steps.html)

---

## Filtering rows

In `R`, you can filter rows/observations dependent on one or more conditions.

To filter rows/observations you can use... 
- **comparison operators**:
    - **<** (smaller than)
    - **<=** (smaller than or equal to)
    - **==** (equal to)
    - **!=** (not equal to)
    - **>=** (larger than or equal to)
    - **>** (larger than)
    - **%in%** (included in)

---

## Filtering rows

... and combine comparisons with
- **logical operators**:
    - **&** (and)
    - **|** (or)
    - **!** (not)
    - **xor** (either or, not both)

---

## Filtering rows

Similar to selecting columns/variables, there are two options for filtering rows/observations with `base R`.

Option 1
```{r filter-base}
allbus_male <-allbus_2021[which(allbus_2021$sex == 1), ]

dim(allbus_male)
```

Option 2
```{r filter-subset}
allbus_male <- subset(allbus_2021, sex == 1)

dim(allbus_male)
```

---

## Filtering rows

The `dplyr` solution for filtering rows/observations is the verb `filter()`.

```{r dplyr-filter-1}
allbus_male <- allbus_2021 %>% 
  filter(sex == 1)

dim(allbus_male)
```

---

## Filtering rows based on multiple conditions

```{r filter-2-cond}
allbus_old_men <- allbus_2021 %>% 
  filter(sex == 1, agec > 3, eastwest !=1)

dim(allbus_old_men)
```

---

## `dplyr::filter()`

```{r, filter-cartoon, out.width = "95%", echo = F}
knitr::include_graphics("https://github.com/allisonhorst/stats-illustrations/raw/main/rstats-artwork/dplyr_filter.jpg")
```
<small><small>Illustration by [Allison Horst](https://github.com/allisonhorst/stats-illustrations) </small></small>

---

## `dplyr::filter` - multiple conditions

By default, multiple conditions in `filter()` are added as *&* (and). You can, however, also specify multiple conditions differently.

**or** (cases for which at least one of the conditions is true)

```{r filter-or}
allbus_old_andor_male <- allbus_2021 %>% 
  filter(sex == 1 |
           agec > 3)

dim(allbus_old_andor_male)
```

---

## `dplyr::filter` - multiple conditions

**xor** (cases for which only one of the two conditions is true)

```{r filter-xor}
allbus_old_or_male <- allbus_2021 %>%
  filter(xor(sex == 1, 
             agec > 3))

dim(allbus_old_or_male )
```

---

## Advanced ways of filtering rows

Similar to `select()` there are some helper functions for `filter()` for advanced filtering of rows. For example, you can...

 - Filter rows based on a range in a numeric variable

```{r between}
allbus_centrist <- allbus_2021 %>% 
    filter(between(pa01, 4, 6))

dim(allbus_centrist)
```

*Note*: The range specified in `between()` is inclusive (on both sides).

---

## Advanced ways of filtering rows

- Filter rows based on the values of specific variables matching certain criteria

```{r if-all}
allbus_trust_high  <- allbus_2021 %>% 
  filter(if_all(starts_with ("pt"), ~ . >5)) # read: if the values of variables starting with pt in this df are > 5 (indicating high trust)

dim(allbus_trust_high)
```

*Note*: The helper function `if_any()` can be used to specify that at least one of the variables needs to match a certain criterion.

---

## Selecting columns + filtering rows

Of course, you can also combine the selection of columns and the filtering of rows.

`Base R` option 1
```{r colsrows-base}
allbus_antisemit_male  <- allbus_2021[which(allbus_2021$sex == 1), c("mj01", "mj02", "mj03", "mj04", "mj05", "mj06")]

dim(allbus_antisemit_male)
```

`Base R` option 2
```{r colsrows-subset}
allbus_antisemit_male  <- subset(allbus_2021, sex == 1, select = c(mj01, mj02, mj03, mj04, mj05, mj06))

dim(allbus_antisemit_male)
```

---

## Selecting columns + filtering rows

The `tidyverse` approach solution for combining the selection of columns and the filtering of rows is chaining these steps together in a pipe (in this case, the order of the pipe steps does not matter).

```{r dplyr-select-filter}
allbus_antisemit_male  <- allbus_2021 %>% 
  filter(sex == 1) %>% 
  select(mj01:mj06)

dim(allbus_antisemit_male)
```

---

## (Re-)Arranging the order of rows

Again, while this does not directly matter for analyses or plotting (unless you want to filter rows by their numeric index), you can rearrange the order of rows in a data set. In `base R` this can be achieved as follows:

```{r base-sort-1-var}
allbus_2021<- allbus_2021[order(allbus_2021$agec),]

head(allbus_2021[, 5:16])
```

---

## (Re-)Arranging the order of rows

Of course, it is also possible to sort a data frame in descending order of a variable.

```{r base-sort-1-var-desc}
allbus_2021<- allbus_2021[order(desc(allbus_2021$agec)),]

head(allbus_2021[, 5:16])
```

---

## (Re-)Arranging the order of rows

You can also sort your data frame by more than one variable.

```{r base-sort-mult}
allbus_2021 <- allbus_2021[order(allbus_2021$agec, allbus_2021$educ),]

head(allbus_2021[, 6:13])
```

---

## (Re-)Arranging the order of rows

The `dplyr` verb for changing the order of rows in a data set is `arrange()` and you can use it in the same ways as the `base R` equivalent: Sorting by a single variable in ascending order, ...

```{r arrange}
allbus_2021 %>% 
  arrange(agec) %>% 
  select(6:13) %>% 
  glimpse()
```

---

## (Re-)Arranging the order of rows

... sorting by a single variable in descending order, ...

```{r arrange-desc}
allbus_2021 %>% 
  arrange(desc(agec)) %>% 
  select(6:13) %>% 
  glimpse()
```

---

## (Re-)Arranging the order of rows

... sorting by more than one variable.

```{r arrange-mult}
allbus_2021 %>% 
  arrange(agec, educ) %>% 
  select(6:13) %>% 
  glimpse()
```

---

class: center, middle

# [Exercise](https://github.com/StefanJuenger/r-intro-gesis-2022/blob/main/exercises/Exercise_2_1_2_Filter_Arrange.html) time `r ji("weight_lifting_woman")``r ji("muscle")``r ji("running_man")``r ji("biking_man")`

## [Solutions](https://github.com/StefanJuenger/r-intro-gesis-2022/blob/main/solutions/Exercise_2_1_2_Filter_Arrange.html)



